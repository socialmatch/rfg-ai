/**
 * Aster Finance Futures API Service
 * Supports account info query, position query and other functions
 */

import { ethers } from 'ethers'
import { getEnabledAccounts } from '@/config/accounts.js'

// API configuration
const ASTER_API_BASE = 'https://fapi.asterdex.com'

/**
 * Generate Aster Finance signature (correct implementation based on ethers.js)
 * @param {Object} params - Parameter object
 * @param {string} user_address - User address
 * @param {string} signer_address - Signer address
 * @param {string} private_key - Private key
 * @returns {Promise<Object>} Parameter object with signature
 */
const signParams = async (params, user_address, signer_address, private_key) => {
  try {
    // Add necessary parameters
    const timestamp = Math.floor(Date.now() / 1000)
    const recvWindow = 50000

    params.timestamp = timestamp
    params.recvWindow = recvWindow

    // Generate nonce (millisecond timestamp)
    const nonce = Math.floor(Date.now() * 1000)

    // Serialize parameters
    const normalized = stringifyParams(params)
    const jsonStr = JSON.stringify(normalized, Object.keys(normalized).sort())

    console.log('üìù JSON payload:', jsonStr)

    // Use ethers.js AbiCoder encoding
    const data = ethers.AbiCoder.defaultAbiCoder().encode(
      ['string', 'address', 'address', 'uint256'],
      [jsonStr, user_address, signer_address, nonce]
    )

    console.log('üîê Encoded data:', data)

    const digest = ethers.keccak256(data)
    console.log('üîë Digest:', digest)

    // Use ethers.js signing
    const wallet = new ethers.Wallet(private_key)
    const digestBytes = ethers.getBytes(digest)
    const signature = await wallet.signMessage(digestBytes)
    console.log('‚úçÔ∏è Signature:', signature)

    // Return parameters with signature
    const signed = { ...normalized }
    signed.nonce = nonce.toString()
    signed.user = user_address
    signed.signer = signer_address
    signed.signature = signature

    return signed
  } catch (error) {
    console.error('Signature generation failed:', error, user_address)
    throw error
  }
}

/**
 * Convert parameters to string format (based on Python example stringify_params function)
 */
const stringifyParams = (params) => {
  const normalized = {}

  for (const [key, value] of Object.entries(params)) {
    if (typeof value === 'boolean') {
      normalized[key] = value ? 'true' : 'false'
    } else if (typeof value === 'number') {
      if (Number.isInteger(value)) {
        normalized[key] = value.toString()
      } else {
        // Float formatting, remove trailing zeros
        normalized[key] = value.toFixed(10).replace(/\.?0+$/, '')
      }
    } else {
      normalized[key] = String(value)
    }
  }

  return normalized
}


/**
 * Generate query string
 * @param {Object} params - Parameter object
 * @returns {string} Query string
 */
const generateQueryString = (params) => {
  const sortedKeys = Object.keys(params).sort()
  return sortedKeys.map(key => `${key}=${encodeURIComponent(params[key])}`).join('&')
}

/**
 * Add timestamp and signature to parameters
 * @param {Object} params - Original parameters
 * @param {Object} accountConfig - Account configuration
 * @returns {Promise<Object>} Parameters with timestamp and signature
 */
const addTimestampAndSignature = async (params, accountConfig) => {
  try {
    // Use new signature function
    const signedParams = await signParams(
      params,
      accountConfig.user_address,
      accountConfig.signer_address,
      ''
    )

    return signedParams
  } catch (error) {
    console.error('Failed to add signature:', error)
    throw error
  }
}

/**
 * Send API request
 * @param {string} endpoint - API endpoint
 * @param {string} method - HTTP method
 * @param {Object} params - Request parameters
 * @param accountConfig
 * @returns {Promise<Object>} API response
 */
const sendApiRequest = async (endpoint, method = 'GET', params = {}, accountConfig) => {
  try {
    const url = `${ASTER_API_BASE}${endpoint}`
    let requestOptions = {
      method: method,
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        'X-MBX-APIKEY': accountConfig.signer_address
      }
    }

    if (method === 'GET') {
      // GET request adds parameters to URL
      const paramsWithAuth = await addTimestampAndSignature(params, accountConfig)
      const queryString = generateQueryString(paramsWithAuth)
      const fullUrl = `${url}?${queryString}`

      console.log('üîç API request debug info:')
      console.log('URL:', fullUrl)
      console.log('Headers:', requestOptions.headers)
      console.log('Query String:', queryString)

      const response = await fetch(fullUrl, requestOptions)

      if (!response.ok) {
        const errorText = await response.text()
        console.error('‚ùå API error response:', errorText)
        throw new Error(`API request failed: ${response.status} ${response.statusText}`)
      }

      return await response.json()
    } else {
      // POST/PUT/DELETE request puts parameters in body
      const paramsWithAuth = await addTimestampAndSignature(params, accountConfig)
      const formData = new URLSearchParams()

      Object.entries(paramsWithAuth).forEach(([key, value]) => {
        formData.append(key, value)
      })

      requestOptions.body = formData

      const response = await fetch(url, requestOptions)

      if (!response.ok) {
        throw new Error(`API request failed: ${response.status} ${response.statusText}`)
      }

      return await response.json()
    }
  } catch (error) {
    console.error('API request error:', error)
    throw error
  }
}

/**
 * Ëé∑ÂèñÂçï‰∏™Ë¥¶Êà∑‰ø°ÊÅØ
 * @param {Object} accountConfig - Ë¥¶Êà∑ÈÖçÁΩÆ
 * @returns {Promise<Object>} Ë¥¶Êà∑‰ø°ÊÅØ
 */
export const getAccountInfo = async (accountConfig) => {
  try {
    console.log(`Getting ${accountConfig.modelName} account info...`)

    // Try using real API
    try {
      const accountInfo = await sendApiRequest('/fapi/v3/account', 'GET', {}, accountConfig)

      console.log(`‚úÖ ${accountConfig.modelName} real API account info retrieved successfully:`, {
        canTrade: accountInfo.canTrade,
        totalWalletBalance: accountInfo.totalWalletBalance,
        totalUnrealizedProfit: accountInfo.totalUnrealizedProfit,
        assetsCount: accountInfo.assets?.length || 0,
        positionsCount: accountInfo.positions?.length || 0
      })

      return {
        success: true,
        data: accountInfo,
        modelInfo: {
          id: accountConfig.id,
          name: accountConfig.modelName,
          slug: accountConfig.modelSlug,
          color: accountConfig.modelColor
        },
        timestamp: new Date().toISOString()
      }
    } catch (apiError) {
      console.warn(`‚ö†Ô∏è ${accountConfig.modelName}ÁúüÂÆûAPIË∞ÉÁî®Â§±Ë¥•:`, apiError.message)

      return {
        success: false,
        error: apiError.message,
        data: {
          canTrade: false,
          totalWalletBalance: '0.00000000',
          totalUnrealizedProfit: '0.00000000',
          totalMarginBalance: '0.00000000',
          totalPositionInitialMargin: '0.00000000',
          totalOpenOrderInitialMargin: '0.00000000',
          totalCrossWalletBalance: '0.00000000',
          totalCrossUnPnl: '0.00000000',
          availableBalance: '0.00000000',
          maxWithdrawAmount: '0.00000000',
          assets: [],
          positions: []
        },
        modelInfo: {
          id: accountConfig.id,
          name: accountConfig.modelName,
          slug: accountConfig.modelSlug,
          color: accountConfig.modelColor
        },
        timestamp: new Date().toISOString()
      }
    }
  } catch (error) {
    console.error(`‚ùå Ëé∑Âèñ${accountConfig.modelName}Ë¥¶Êà∑‰ø°ÊÅØÂ§±Ë¥•:`, error)
    return {
      success: false,
      error: error.message,
      data: null,
      modelInfo: {
        id: accountConfig.id,
        name: accountConfig.modelName,
        slug: accountConfig.modelSlug,
        color: accountConfig.modelColor
      },
      timestamp: new Date().toISOString()
    }
  }
}

/**
 * Ëé∑ÂèñÊâÄÊúâË¥¶Êà∑‰ø°ÊÅØ
 * @returns {Promise<Array>} ÊâÄÊúâË¥¶Êà∑‰ø°ÊÅØ
 */
export const getAllAccountsInfo = async () => {
  try {
    console.log('Ê≠£Âú®Ëé∑ÂèñÊâÄÊúâË¥¶Êà∑‰ø°ÊÅØ...')

    const enabledAccounts = getEnabledAccounts()
    const accountPromises = enabledAccounts.map(accountConfig =>
      getAccountInfo(accountConfig)
    )

    const results = await Promise.allSettled(accountPromises)

    const successfulResults = results
      .filter(result => result.status === 'fulfilled' && result.value.success)
      .map(result => result.value)

    const failedResults = results
      .filter(result => result.status === 'rejected' || !result.value.success)
      .map(result => result.status === 'rejected' ? result.reason : result.value)

    console.log(`‚úÖ ÊàêÂäüËé∑Âèñ${successfulResults.length}‰∏™Ë¥¶Êà∑‰ø°ÊÅØ`)
    if (failedResults.length > 0) {
      console.warn(`‚ö†Ô∏è ${failedResults.length}‰∏™Ë¥¶Êà∑‰ø°ÊÅØËé∑ÂèñÂ§±Ë¥•`)
    }

    return {
      success: true,
      accounts: successfulResults,
      failed: failedResults,
      timestamp: new Date().toISOString()
    }
  } catch (error) {
    console.error('‚ùå Ëé∑ÂèñÊâÄÊúâË¥¶Êà∑‰ø°ÊÅØÂ§±Ë¥•:', error)
    return {
      success: false,
      error: error.message,
      accounts: [],
      failed: [],
      timestamp: new Date().toISOString()
    }
  }
}



/**
 * Ëé∑ÂèñË¥¶Êà∑ËµÑ‰∫ß‰ø°ÊÅØ
 * @returns {Promise<Object>} ËµÑ‰∫ß‰ø°ÊÅØ
 */
export const getAccountAssets = async () => {
  try {
    const result = await getAccountInfo()

    if (!result.success) {
      return result
    }

    const assets = result.data.assets || []

    return {
      success: true,
      data: {
        totalWalletBalance: result.data.totalWalletBalance,
        totalUnrealizedProfit: result.data.totalUnrealizedProfit,
        availableBalance: result.data.availableBalance,
        maxWithdrawAmount: result.data.maxWithdrawAmount,
        assets: assets
      },
      timestamp: new Date().toISOString()
    }
  } catch (error) {
    console.error('‚ùå Ëé∑ÂèñË¥¶Êà∑ËµÑ‰∫ßÂ§±Ë¥•:', error)
    return {
      success: false,
      error: error.message,
      data: null,
      timestamp: new Date().toISOString()
    }
  }
}

/**
 * Ëé∑ÂèñÊåÅ‰ªì‰ø°ÊÅØ
 * @returns {Promise<Object>} ÊåÅ‰ªì‰ø°ÊÅØ
 */
export const getPositions = async () => {
  try {
    const result = await getAccountInfo()

    if (!result.success) {
      return result
    }

    const positions = result.data.positions || []

    // ËøáÊª§ÊéâÊåÅ‰ªìÊï∞Èáè‰∏∫0ÁöÑ‰ªì‰Ωç
    const activePositions = positions.filter(position =>
      parseFloat(position.positionAmt) !== 0
    )

    return {
      success: true,
      data: {
        totalPositions: positions.length,
        activePositions: activePositions.length,
        positions: activePositions
      },
      timestamp: new Date().toISOString()
    }
  } catch (error) {
    console.error('‚ùå Ëé∑ÂèñÊåÅ‰ªì‰ø°ÊÅØÂ§±Ë¥•:', error)
    return {
      success: false,
      error: error.message,
      data: null,
      timestamp: new Date().toISOString()
    }
  }
}

/**
 * Ëé∑ÂèñÁâπÂÆöË¥¶Êà∑ÁöÑÊåÅ‰ªì‰ø°ÊÅØ
 * @param {Object} accountConfig - Ë¥¶Êà∑ÈÖçÁΩÆ
 * @returns {Promise<Object>} ÊåÅ‰ªì‰ø°ÊÅØ
 */
export const getAccountPositions = async (accountConfig) => {
  try {
    console.log(`Ê≠£Âú®Ëé∑Âèñ${accountConfig.modelName}Ë¥¶Êà∑ÊåÅ‰ªì‰ø°ÊÅØ...`)

    try {
      const result = await getAccountInfo(accountConfig)

      if (!result.success) {
        return result
      }

      const positions = result.data.positions || []

      // ËøáÊª§ÊéâÊåÅ‰ªìÊï∞Èáè‰∏∫0ÁöÑ‰ªì‰Ωç
      const activePositions = positions.filter(position =>
        parseFloat(position.positionAmt) !== 0
      )

      console.log(`‚úÖ ${accountConfig.modelName}ÁúüÂÆûAPIÊåÅ‰ªìËé∑ÂèñÊàêÂäü:`, {
        totalPositions: positions.length,
        activePositions: activePositions.length
      })

      return {
        success: true,
        data: {
          totalPositions: positions.length,
          activePositions: activePositions.length,
          positions: activePositions
        },
        modelInfo: {
          id: accountConfig.id,
          name: accountConfig.modelName,
          slug: accountConfig.modelSlug,
          color: accountConfig.modelColor
        },
        timestamp: new Date().toISOString()
      }
    } catch (apiError) {
      console.warn(`‚ö†Ô∏è ${accountConfig.modelName}ÁúüÂÆûAPIÊåÅ‰ªìË∞ÉÁî®Â§±Ë¥•:`, apiError.message)

      return {
        success: false,
        error: apiError.message,
        data: {
          totalPositions: 0,
          activePositions: 0,
          positions: []
        },
        modelInfo: {
          id: accountConfig.id,
          name: accountConfig.modelName,
          slug: accountConfig.modelSlug,
          color: accountConfig.modelColor
        },
        timestamp: new Date().toISOString()
      }
    }
  } catch (error) {
    console.error(`‚ùå Ëé∑Âèñ${accountConfig.modelName}Ë¥¶Êà∑ÊåÅ‰ªìÂ§±Ë¥•:`, error)
    return {
      success: false,
      error: error.message,
      data: {
        totalPositions: 0,
        activePositions: 0,
        positions: []
      },
      modelInfo: {
        id: accountConfig.id,
        name: accountConfig.modelName,
        slug: accountConfig.modelSlug,
        color: accountConfig.modelColor
      },
      timestamp: new Date().toISOString()
    }
  }
}

/**
 * Ëé∑ÂèñË¥¶Êà∑Ê¶ÇËßà‰ø°ÊÅØ
 * @returns {Promise<Object>} Ë¥¶Êà∑Ê¶ÇËßà
 */
export const getAccountOverview = async () => {
  try {
    const result = await getAccountInfo()

    if (!result.success) {
      return result
    }

    const accountData = result.data

    return {
      success: true,
      data: {
        // Âü∫Êú¨Áä∂ÊÄÅ
        canTrade: accountData.canTrade,
        canDeposit: accountData.canDeposit,
        canWithdraw: accountData.canWithdraw,

        // ËµÑÈáë‰ø°ÊÅØ
        totalWalletBalance: accountData.totalWalletBalance,
        totalUnrealizedProfit: accountData.totalUnrealizedProfit,
        totalMarginBalance: accountData.totalMarginBalance,
        availableBalance: accountData.availableBalance,
        maxWithdrawAmount: accountData.maxWithdrawAmount,

        // ‰øùËØÅÈáë‰ø°ÊÅØ
        totalInitialMargin: accountData.totalInitialMargin,
        totalMaintMargin: accountData.totalMaintMargin,

        // ËµÑ‰∫ßÂíåÊåÅ‰ªìÁªüËÆ°
        assetsCount: accountData.assets?.length || 0,
        positionsCount: accountData.positions?.length || 0,
        activePositionsCount: accountData.positions?.filter(p => parseFloat(p.positionAmt) !== 0).length || 0,

        // Êõ¥Êñ∞Êó∂Èó¥
        updateTime: accountData.updateTime
      },
      timestamp: new Date().toISOString()
    }
  } catch (error) {
    console.error('‚ùå Ëé∑ÂèñË¥¶Êà∑Ê¶ÇËßàÂ§±Ë¥•:', error)
    return {
      success: false,
      error: error.message,
      data: null,
      timestamp: new Date().toISOString()
    }
  }
}

/**
 * ÊµãËØïAPIËøûÊé•
 * @returns {Promise<Object>} ÊµãËØïÁªìÊûú
 */
export const testApiConnection = async () => {
  try {
    console.log('üß™ ÊµãËØïAster Finance APIËøûÊé•...')

    const result = await getAllAccountsInfo()

    if (result.success) {
      console.log('‚úÖ APIËøûÊé•ÊµãËØïÊàêÂäü')
      return {
        success: true,
        message: 'APIËøûÊé•Ê≠£Â∏∏',
        accounts: result.accounts,
        failed: result.failed,
        totalAccounts: result.accounts.length + result.failed.length,
        successCount: result.accounts.length,
        failedCount: result.failed.length
      }
    } else {
      console.log('‚ùå APIËøûÊé•ÊµãËØïÂ§±Ë¥•')
      return {
        success: false,
        message: 'APIËøûÊé•Â§±Ë¥•',
        error: result.error
      }
    }
  } catch (error) {
    console.error('‚ùå APIËøûÊé•ÊµãËØïÂºÇÂ∏∏:', error)
    return {
      success: false,
      message: 'APIËøûÊé•ÂºÇÂ∏∏',
      error: error.message
    }
  }
}

/**
 * Ëé∑ÂèñÂçï‰∏™Ë¥¶Êà∑ÁöÑ‰∫§ÊòìÂéÜÂè≤
 * @param {Object} accountConfig - Ë¥¶Êà∑ÈÖçÁΩÆ
 * @param {Object} params - Êü•ËØ¢ÂèÇÊï∞
 * @returns {Promise<Object>} ‰∫§ÊòìÂéÜÂè≤Êï∞ÊçÆ
 */
export const getUserTrades = async (accountConfig, params = {}) => {
  try {
    console.log(`Ê≠£Âú®Ëé∑Âèñ${accountConfig.modelName}Ë¥¶Êà∑‰∫§ÊòìÂéÜÂè≤...`)

    // ËÆæÁΩÆÈªòËÆ§ÂèÇÊï∞
    const defaultParams = {
      limit: 1000, // ÈªòËÆ§Ëé∑Âèñ1000Êù°ËÆ∞ÂΩï
      ...params
    }

    // Try using real API
    try {
      const userTrades = await sendApiRequest('/fapi/v3/userTrades', 'GET', defaultParams, accountConfig)

      console.log(`‚úÖ ${accountConfig.modelName}ÁúüÂÆûAPI‰∫§ÊòìÂéÜÂè≤Ëé∑ÂèñÊàêÂäü:`, {
        tradesCount: userTrades?.length || 0,
        params: defaultParams
      })

      return {
        success: true,
        data: userTrades || [],
        modelInfo: {
          id: accountConfig.id,
          name: accountConfig.modelName,
          slug: accountConfig.modelSlug,
          color: accountConfig.modelColor
        },
        timestamp: new Date().toISOString()
      }
    } catch (apiError) {
      console.warn(`‚ö†Ô∏è ${accountConfig.modelName}ÁúüÂÆûAPI‰∫§ÊòìÂéÜÂè≤Ë∞ÉÁî®Â§±Ë¥•:`, apiError.message)

      return {
        success: false,
        error: apiError.message,
        data: [],
        modelInfo: {
          id: accountConfig.id,
          name: accountConfig.modelName,
          slug: accountConfig.modelSlug,
          color: accountConfig.modelColor
        },
        timestamp: new Date().toISOString()
      }
    }
  } catch (error) {
    console.error(`‚ùå Ëé∑Âèñ${accountConfig.modelName}Ë¥¶Êà∑‰∫§ÊòìÂéÜÂè≤Â§±Ë¥•:`, error)
    return {
      success: false,
      error: error.message,
      data: [],
      modelInfo: {
        id: accountConfig.id,
        name: accountConfig.modelName,
        slug: accountConfig.modelSlug,
        color: accountConfig.modelColor
      },
      timestamp: new Date().toISOString()
    }
  }
}

/**
 * Ëé∑ÂèñÊâÄÊúâË¥¶Êà∑ÁöÑ‰∫§ÊòìÂéÜÂè≤
 * @param {Object} params - Êü•ËØ¢ÂèÇÊï∞
 * @returns {Promise<Object>} ÊâÄÊúâË¥¶Êà∑‰∫§ÊòìÂéÜÂè≤Êï∞ÊçÆ
 */
export const getAllAccountsUserTrades = async (params = {}) => {
  try {
    console.log('Ê≠£Âú®Ëé∑ÂèñÊâÄÊúâË¥¶Êà∑‰∫§ÊòìÂéÜÂè≤...')
    const enabledAccounts = getEnabledAccounts()
    const tradesPromises = enabledAccounts.map(accountConfig =>
      getUserTrades(accountConfig, params)
    )
    const results = await Promise.allSettled(tradesPromises)
    const successfulResults = results
      .filter(result => result.status === 'fulfilled' && result.value.success)
      .map(result => result.value)
    const failedResults = results
      .filter(result => result.status === 'rejected' || !result.value.success)
      .map(result => result.status === 'rejected' ? result.reason : result.value)

    console.log(`‚úÖ ÊàêÂäüËé∑Âèñ${successfulResults.length}‰∏™Ë¥¶Êà∑‰∫§ÊòìÂéÜÂè≤`)
    if (failedResults.length > 0) {
      console.warn(`‚ö†Ô∏è ${failedResults.length}‰∏™Ë¥¶Êà∑‰∫§ÊòìÂéÜÂè≤Ëé∑ÂèñÂ§±Ë¥•`)
    }

    return {
      success: true,
      accounts: successfulResults,
      failed: failedResults,
      timestamp: new Date().toISOString()
    }
  } catch (error) {
    console.error('‚ùå Ëé∑ÂèñÊâÄÊúâË¥¶Êà∑‰∫§ÊòìÂéÜÂè≤Â§±Ë¥•:', error)
    return {
      success: false,
      error: error.message,
      accounts: [],
      failed: [],
      timestamp: new Date().toISOString()
    }
  }
}

/**
 * Ëé∑ÂèñÂçï‰∏™Ë¥¶Êà∑ÁöÑ‰ΩôÈ¢ù‰ø°ÊÅØ
 * @param {Object} accountConfig - Ë¥¶Êà∑ÈÖçÁΩÆ
 * @param {Object} params - Êü•ËØ¢ÂèÇÊï∞
 * @returns {Promise<Object>} Ë¥¶Êà∑‰ΩôÈ¢ùÊï∞ÊçÆ
 */
export const getAccountBalance = async (accountConfig, params = {}) => {
  try {
    console.log(`Ê≠£Âú®Ëé∑Âèñ${accountConfig.modelName}Ë¥¶Êà∑‰ΩôÈ¢ù...`)

    const defaultParams = {
      ...params
    }

    try {
      const balance = await sendApiRequest('/fapi/v3/balance', 'GET', defaultParams, accountConfig)

      console.log(`‚úÖ ${accountConfig.modelName}ÁúüÂÆûAPI‰ΩôÈ¢ùËé∑ÂèñÊàêÂäü:`, {
        balanceCount: balance?.length || 0,
        params: defaultParams
      })

      return {
        success: true,
        data: balance || [],
        modelInfo: {
          id: accountConfig.id,
          name: accountConfig.modelName,
          slug: accountConfig.modelSlug,
          color: accountConfig.modelColor
        },
        timestamp: new Date().toISOString()
      }
    } catch (apiError) {
      console.warn(`‚ö†Ô∏è ${accountConfig.modelName}ÁúüÂÆûAPI‰ΩôÈ¢ùË∞ÉÁî®Â§±Ë¥•:`, apiError.message)
      return {
        success: false,
        error: apiError.message,
        data: [],
        modelInfo: {
          id: accountConfig.id,
          name: accountConfig.modelName,
          slug: accountConfig.modelSlug,
          color: accountConfig.modelColor
        },
        timestamp: new Date().toISOString()
      }
    }
  } catch (error) {
    console.error(`‚ùå Ëé∑Âèñ${accountConfig.modelName}Ë¥¶Êà∑‰ΩôÈ¢ùÂ§±Ë¥•:`, error)
    return {
      success: false,
      error: error.message,
      data: [],
      modelInfo: {
        id: accountConfig.id,
        name: accountConfig.modelName,
        slug: accountConfig.modelSlug,
        color: accountConfig.modelColor
      },
      timestamp: new Date().toISOString()
    }
  }
}

/**
 * Ëé∑ÂèñÊâÄÊúâË¥¶Êà∑ÁöÑ‰ΩôÈ¢ù‰ø°ÊÅØ
 * @param {Object} params - Êü•ËØ¢ÂèÇÊï∞
 * @returns {Promise<Object>} ÊâÄÊúâË¥¶Êà∑‰ΩôÈ¢ùÊï∞ÊçÆ
 */
export const getAllAccountsBalance = async (params = {}) => {
  try {
    console.log('Ê≠£Âú®Ëé∑ÂèñÊâÄÊúâË¥¶Êà∑‰ΩôÈ¢ù...')
    const enabledAccounts = getEnabledAccounts()
    const balancePromises = enabledAccounts.map(accountConfig =>
      getAccountBalance(accountConfig, params)
    )
    const results = await Promise.allSettled(balancePromises)
    const successfulResults = results
      .filter(result => result.status === 'fulfilled' && result.value.success)
      .map(result => result.value)
    const failedResults = results
      .filter(result => result.status === 'rejected' || !result.value.success)
      .map(result => result.status === 'rejected' ? result.reason : result.value)

    console.log(`‚úÖ ÊàêÂäüËé∑Âèñ${successfulResults.length}‰∏™Ë¥¶Êà∑‰ΩôÈ¢ù`)
    if (failedResults.length > 0) {
      console.warn(`‚ö†Ô∏è ${failedResults.length}‰∏™Ë¥¶Êà∑‰ΩôÈ¢ùËé∑ÂèñÂ§±Ë¥•`)
    }

    return {
      success: true,
      accounts: successfulResults,
      failed: failedResults,
      timestamp: new Date().toISOString()
    }
  } catch (error) {
    console.error('‚ùå Ëé∑ÂèñÊâÄÊúâË¥¶Êà∑‰ΩôÈ¢ùÂ§±Ë¥•:', error)
    return {
      success: false,
      error: error.message,
      accounts: [],
      failed: [],
      timestamp: new Date().toISOString()
    }
  }
}

// ÂØºÂá∫ÈªòËÆ§ÂØπË±°
export default {
  getAccountInfo,
  getAllAccountsInfo,
  getAccountAssets,
  getPositions,
  getAccountPositions,
  getAccountOverview,
  testApiConnection,
  getUserTrades,
  getAllAccountsUserTrades,
  getAccountBalance,
  getAllAccountsBalance
}
